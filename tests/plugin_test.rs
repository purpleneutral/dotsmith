use assert_cmd::Command;
use predicates::prelude::*;
use std::fs;
use tempfile::TempDir;

fn dotsmith() -> Command {
    Command::cargo_bin("dotsmith").unwrap()
}

/// Initialize dotsmith in a temp dir and return the config dir path string.
fn init_env(tmp: &TempDir) -> String {
    let config_dir = tmp.path().join("config");
    let dir_str = config_dir.display().to_string();

    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &dir_str)
        .args(["init"])
        .assert()
        .success();

    dir_str
}

/// Add zsh as a tracked tool by writing directly to the manifest.
fn add_zsh_to_manifest(config_dir: &str) {
    let manifest = r#"[tools.zsh]
tier = 1
config_paths = ["~/.zshrc"]
plugins_managed = false
added_at = "2026-01-01T00:00:00Z"
"#;
    fs::write(format!("{}/manifest.toml", config_dir), manifest).unwrap();
}

/// Add tmux as a tracked tool by writing directly to the manifest.
fn add_tmux_to_manifest(config_dir: &str) {
    let manifest = r#"[tools.tmux]
tier = 1
config_paths = ["~/.config/tmux/tmux.conf"]
plugins_managed = false
added_at = "2026-01-01T00:00:00Z"
"#;
    fs::write(format!("{}/manifest.toml", config_dir), manifest).unwrap();
}

/// Create a fake local git repo that looks like a zsh plugin.
/// Returns the file:// URL that can be used for cloning.
fn create_fake_zsh_plugin(tmp: &TempDir, name: &str) -> String {
    let repo_dir = tmp.path().join(format!("repos/{}", name));
    fs::create_dir_all(&repo_dir).unwrap();

    std::process::Command::new("git")
        .args(["init"])
        .current_dir(&repo_dir)
        .stdout(std::process::Stdio::null())
        .stderr(std::process::Stdio::null())
        .output()
        .unwrap();

    fs::write(
        repo_dir.join(format!("{}.plugin.zsh", name)),
        "# zsh plugin init\n",
    )
    .unwrap();

    std::process::Command::new("git")
        .args(["add", "."])
        .current_dir(&repo_dir)
        .output()
        .unwrap();

    std::process::Command::new("git")
        .args(["commit", "-m", "initial"])
        .current_dir(&repo_dir)
        .env("GIT_AUTHOR_NAME", "test")
        .env("GIT_AUTHOR_EMAIL", "test@test.com")
        .env("GIT_COMMITTER_NAME", "test")
        .env("GIT_COMMITTER_EMAIL", "test@test.com")
        .stdout(std::process::Stdio::null())
        .stderr(std::process::Stdio::null())
        .output()
        .unwrap();

    format!("file://{}", repo_dir.display())
}

/// Create a fake local git repo that looks like a tmux plugin.
fn create_fake_tmux_plugin(tmp: &TempDir, name: &str) -> String {
    let repo_dir = tmp.path().join(format!("repos/{}", name));
    fs::create_dir_all(&repo_dir).unwrap();

    std::process::Command::new("git")
        .args(["init"])
        .current_dir(&repo_dir)
        .stdout(std::process::Stdio::null())
        .stderr(std::process::Stdio::null())
        .output()
        .unwrap();

    fs::write(
        repo_dir.join(format!("{}.tmux", name)),
        "#!/usr/bin/env bash\n",
    )
    .unwrap();

    std::process::Command::new("git")
        .args(["add", "."])
        .current_dir(&repo_dir)
        .output()
        .unwrap();

    std::process::Command::new("git")
        .args(["commit", "-m", "initial"])
        .current_dir(&repo_dir)
        .env("GIT_AUTHOR_NAME", "test")
        .env("GIT_AUTHOR_EMAIL", "test@test.com")
        .env("GIT_COMMITTER_NAME", "test")
        .env("GIT_COMMITTER_EMAIL", "test@test.com")
        .stdout(std::process::Stdio::null())
        .stderr(std::process::Stdio::null())
        .output()
        .unwrap();

    format!("file://{}", repo_dir.display())
}

#[test]
fn test_plugin_add_zsh() {
    let tmp = TempDir::new().unwrap();
    let config_dir = init_env(&tmp);
    add_zsh_to_manifest(&config_dir);

    let repo_url = create_fake_zsh_plugin(&tmp, "test-plugin");

    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "add", &repo_url])
        .assert()
        .success()
        .stdout(predicate::str::contains("Added plugin"))
        .stdout(predicate::str::contains("test-plugin"))
        .stdout(predicate::str::contains("Init file:"));

    // Verify plugin directory was created
    let plugin_dir = format!("{}/plugins/zsh/test-plugin", config_dir);
    assert!(fs::metadata(&plugin_dir).unwrap().is_dir());

    // Verify loader file was created
    let loader_path = format!("{}/plugins/zsh/loader.zsh", config_dir);
    let loader_content = fs::read_to_string(&loader_path).unwrap();
    assert!(loader_content.contains("Auto-generated by dotsmith"));
    assert!(loader_content.contains("source "));
    assert!(loader_content.contains("test-plugin/test-plugin.plugin.zsh"));

    // Verify manifest was updated
    let manifest = fs::read_to_string(format!("{}/manifest.toml", config_dir)).unwrap();
    assert!(manifest.contains("[tools.zsh.plugins.test-plugin]"));
    assert!(manifest.contains("plugins_managed = true"));
}

#[test]
fn test_plugin_add_tmux() {
    let tmp = TempDir::new().unwrap();
    let config_dir = init_env(&tmp);
    add_tmux_to_manifest(&config_dir);

    let repo_url = create_fake_tmux_plugin(&tmp, "tmux-test");

    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "tmux", "add", &repo_url])
        .assert()
        .success()
        .stdout(predicate::str::contains("Added plugin"))
        .stdout(predicate::str::contains("tmux-test"));

    // Verify loader uses run-shell
    let loader_path = format!("{}/plugins/tmux/loader.conf", config_dir);
    let loader_content = fs::read_to_string(&loader_path).unwrap();
    assert!(loader_content.contains("run-shell "));
    assert!(loader_content.contains("tmux-test/tmux-test.tmux"));
}

#[test]
fn test_plugin_list_empty() {
    let tmp = TempDir::new().unwrap();
    let config_dir = init_env(&tmp);
    add_zsh_to_manifest(&config_dir);

    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "list"])
        .assert()
        .success()
        .stdout(predicate::str::contains("No plugins installed"));
}

#[test]
fn test_plugin_list_with_plugins() {
    let tmp = TempDir::new().unwrap();
    let config_dir = init_env(&tmp);
    add_zsh_to_manifest(&config_dir);

    let repo_url = create_fake_zsh_plugin(&tmp, "test-plugin");

    // Add a plugin first
    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "add", &repo_url])
        .assert()
        .success();

    // List should show it
    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "list"])
        .assert()
        .success()
        .stdout(predicate::str::contains("1 plugin(s)"))
        .stdout(predicate::str::contains("test-plugin"));
}

#[test]
fn test_plugin_remove() {
    let tmp = TempDir::new().unwrap();
    let config_dir = init_env(&tmp);
    add_zsh_to_manifest(&config_dir);

    let repo_url = create_fake_zsh_plugin(&tmp, "test-plugin");

    // Add then remove
    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "add", &repo_url])
        .assert()
        .success();

    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "remove", "test-plugin"])
        .assert()
        .success()
        .stdout(predicate::str::contains("Removed plugin"))
        .stdout(predicate::str::contains("test-plugin"));

    // Plugin directory should be gone
    let plugin_dir = format!("{}/plugins/zsh/test-plugin", config_dir);
    assert!(!std::path::Path::new(&plugin_dir).exists());

    // Manifest should no longer have plugins
    let manifest = fs::read_to_string(format!("{}/manifest.toml", config_dir)).unwrap();
    assert!(!manifest.contains("[tools.zsh.plugins"));
    assert!(manifest.contains("plugins_managed = false"));
}

#[test]
fn test_plugin_update() {
    let tmp = TempDir::new().unwrap();
    let config_dir = init_env(&tmp);
    add_zsh_to_manifest(&config_dir);

    let repo_url = create_fake_zsh_plugin(&tmp, "test-plugin");

    // Add plugin
    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "add", &repo_url])
        .assert()
        .success();

    // Update (should be "up to date" since we just cloned)
    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "update"])
        .assert()
        .success()
        .stdout(predicate::str::contains("Updated 0 plugin(s)"))
        .stdout(predicate::str::contains("1 already up to date"));
}

#[test]
fn test_plugin_add_duplicate_fails() {
    let tmp = TempDir::new().unwrap();
    let config_dir = init_env(&tmp);
    add_zsh_to_manifest(&config_dir);

    let repo_url = create_fake_zsh_plugin(&tmp, "test-plugin");

    // Add once
    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "add", &repo_url])
        .assert()
        .success();

    // Add again should fail
    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "add", &repo_url])
        .assert()
        .failure()
        .stderr(predicate::str::contains("already installed"));
}

#[test]
fn test_plugin_remove_nonexistent_fails() {
    let tmp = TempDir::new().unwrap();
    let config_dir = init_env(&tmp);
    add_zsh_to_manifest(&config_dir);

    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "remove", "nonexistent"])
        .assert()
        .failure()
        .stderr(predicate::str::contains("not installed"));
}

#[test]
fn test_plugin_unsupported_tool_fails() {
    let tmp = TempDir::new().unwrap();
    let config_dir = init_env(&tmp);

    // Write a manifest with git tracked
    let manifest = r#"[tools.git]
tier = 2
config_paths = ["~/.gitconfig"]
plugins_managed = false
added_at = "2026-01-01T00:00:00Z"
"#;
    fs::write(format!("{}/manifest.toml", config_dir), manifest).unwrap();

    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "git", "list"])
        .assert()
        .failure()
        .stderr(predicate::str::contains("not supported"));
}

#[test]
fn test_plugin_tool_not_tracked_fails() {
    let tmp = TempDir::new().unwrap();
    let config_dir = init_env(&tmp);

    // Don't add zsh to manifest
    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "list"])
        .assert()
        .failure()
        .stderr(predicate::str::contains("not managed"));
}

#[test]
fn test_plugin_multiple_plugins() {
    let tmp = TempDir::new().unwrap();
    let config_dir = init_env(&tmp);
    add_zsh_to_manifest(&config_dir);

    let repo1 = create_fake_zsh_plugin(&tmp, "plugin-alpha");
    let repo2 = create_fake_zsh_plugin(&tmp, "plugin-beta");

    // Add two plugins
    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "add", &repo1])
        .assert()
        .success();

    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "add", &repo2])
        .assert()
        .success();

    // List should show both
    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "list"])
        .assert()
        .success()
        .stdout(predicate::str::contains("2 plugin(s)"))
        .stdout(predicate::str::contains("plugin-alpha"))
        .stdout(predicate::str::contains("plugin-beta"));

    // Loader should have both source lines
    let loader = fs::read_to_string(format!("{}/plugins/zsh/loader.zsh", config_dir)).unwrap();
    assert!(loader.contains("plugin-alpha/plugin-alpha.plugin.zsh"));
    assert!(loader.contains("plugin-beta/plugin-beta.plugin.zsh"));

    // Remove one, verify the other remains
    dotsmith()
        .env("DOTSMITH_CONFIG_DIR", &config_dir)
        .args(["plugins", "zsh", "remove", "plugin-alpha"])
        .assert()
        .success();

    let loader = fs::read_to_string(format!("{}/plugins/zsh/loader.zsh", config_dir)).unwrap();
    assert!(!loader.contains("plugin-alpha"));
    assert!(loader.contains("plugin-beta"));

    // Manifest should still be managed
    let manifest = fs::read_to_string(format!("{}/manifest.toml", config_dir)).unwrap();
    assert!(manifest.contains("plugins_managed = true"));
}
